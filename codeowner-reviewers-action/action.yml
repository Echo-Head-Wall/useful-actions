name: 'Get CODEOWNER reviewers'
description: 'Gets the CODEOWNER reviewers for changed files in a PR and posts them as a comment'
permissions: write-all
inputs:
  custom_message:
    description: 'Optional custom message to include in the comment'
    required: false
    default: ''
  codeowners_path:
    description: 'Path to the CODEOWNERS file'
    required: false
    default: '.github/CODEOWNERS'
  security_reviewers:
    description: 'Comma-separated list of security reviewers to include'
    required: false
    default: ''
outputs:
  reviewers:
    description: 'List of reviewers found for the changed files'
    value: ${{ steps.get-reviewers.outputs.reviewers }}

runs:
  using: "composite"
  steps:
    - name: Get CODEOWNERS reviewers
      id: get-reviewers
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          // Get changed files in the PR
          const { data: changedFiles } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          
          // Get CODEOWNERS file
          const codeownersPath = core.getInput('codeowners_path') || '.github/CODEOWNERS';
          console.log(`Input codeowners_path value: '${core.getInput('codeowners_path')}'`);
          console.log(`Using codeowners_path: '${codeownersPath}'`);
          let codeownersContent = '';
          
          try {
            console.log(`Attempting to read CODEOWNERS file from path: ${codeownersPath}`);
            
            // Use Node.js fs module to read the file directly from the filesystem
            const fs = require('fs');
            const path = require('path');
            
            // Try to read the file from the specified path
            try {
              if (fs.existsSync(codeownersPath)) {
                console.log(`Found CODEOWNERS file at: ${codeownersPath}`);
                codeownersContent = fs.readFileSync(codeownersPath, 'utf8');
                console.log(`CODEOWNERS content first 100 chars: ${codeownersContent.substring(0, 100)}`);
              } else {
                console.log(`File not found at specified path: ${codeownersPath}, trying common locations...`);
                
                // Try common locations
                const commonLocations = [
                  '.github/CODEOWNERS',
                  'CODEOWNERS',
                  'docs/CODEOWNERS',
                  '.gitlab/CODEOWNERS'
                ];
                
                let found = false;
                for (const location of commonLocations) {
                  if (location === codeownersPath) continue; // Skip if we already tried this path
                  
                  if (fs.existsSync(location)) {
                    console.log(`Found CODEOWNERS at alternate location: ${location}`);
                    codeownersContent = fs.readFileSync(location, 'utf8');
                    console.log(`CODEOWNERS content first 100 chars: ${codeownersContent.substring(0, 100)}`);
                    found = true;
                    break;
                  }
                }
                
                if (!found) {
                  throw new Error(`CODEOWNERS file not found at ${codeownersPath} or any common locations`);
                }
              }
            } catch (fsError) {
              throw new Error(`Error reading CODEOWNERS file: ${fsError.message}`);
            }
          } catch (error) {
            console.log(`Error retrieving CODEOWNERS file: ${error.message}`);
            console.log(`Error details: ${JSON.stringify(error)}`);
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚ö†Ô∏è CODEOWNERS Error\n\nThere was an error processing the CODEOWNERS file at \`${codeownersPath}\`.\n\nError: \`${error.message}\`\n\nPlease check the GitHub Actions logs for more details.`
            });
            
            core.setFailed(`Failed to process CODEOWNERS file: ${error.message}`);
            core.setOutput('reviewers', '');
            return;
          }
          
          // Only proceed if we have content
          if (!codeownersContent || codeownersContent.trim() === '') {
            console.log('CODEOWNERS file is empty. Exiting.');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚ö†Ô∏è CODEOWNERS Warning\n\nThe CODEOWNERS file at \`${codeownersPath}\` exists but is empty.`
            });
            core.setOutput('reviewers', '');
            return;
          }
          
          const reviewers = new Set();
          
          // Parse CODEOWNERS file and create path patterns
          const codeownerRules = [];
          codeownersContent.split('\n').forEach(line => {
            if (line && !line.startsWith('#')) {
              const [pattern, ...owners] = line.trim().split(/\s+/);
              if (pattern && owners.length > 0) {
                codeownerRules.push({
                  pattern: pattern,
                  owners: owners.filter(owner => owner.startsWith('@'))
                });
              }
            }
          });
          
          // Sort rules by specificity (most specific first)
          codeownerRules.sort((a, b) => {
            const aDepth = a.pattern.split('/').length;
            const bDepth = b.pattern.split('/').length;
            return bDepth - aDepth;
          });
          
          // For each changed file, find matching CODEOWNERS rules
          changedFiles.forEach(file => {
            const filePath = file.filename;
            for (const rule of codeownerRules) {
              // Convert glob pattern to regex
              const pattern = rule.pattern
                .replace(/\*/g, '.*')
                // Convert single character wildcard ? to match any single character
                .replace(/\?/g, '.')
                // Preserve opening square bracket for character sets
                .replace(/\[/g, '[')
                // Preserve closing square bracket for character sets
                .replace(/\]/g, ']');
              const regex = new RegExp(`^${pattern}$`);
              
              if (regex.test(filePath)) {
                rule.owners.forEach(owner => reviewers.add(owner));
                break; // Stop at first match (most specific rule)
              }
            }
          });
          
          // Format the message
          const customMessage = core.getInput('custom_message');
          const securityReviewers = core.getInput('security_reviewers') ? core.getInput('security_reviewers').split(',').map(r => r.trim()) : [];
          
          // Separate regular reviewers from security reviewers
          const regularReviewers = new Set(Array.from(reviewers).filter(reviewer => !securityReviewers.includes(reviewer)));
          const codeownerSecurityReviewers = new Set(Array.from(reviewers).filter(reviewer => securityReviewers.includes(reviewer)));
          
          let message = `## üë• Required Reviewers\n\n`;
          
          if (regularReviewers.size > 0) {
            message += `### Reviewers for this PR:\n\n`;
            message += Array.from(regularReviewers).map(reviewer => `- ${reviewer}`).join('\n');
            message += '\n\n';
            message += `> üí° These reviewers were automatically assigned based on the files changed in this PR.\n`;
          } else if (codeownerSecurityReviewers.size === 0) {
            message += `> ‚ö†Ô∏è No CODEOWNERS found for the changed files in this PR.\n`;
            message += `> Please ensure you have a CODEOWNERS file set up in your repository.\n\n`;
          }
          
          if (codeownerSecurityReviewers.size > 0 || securityReviewers.length > 0) {
            message += `\n## üîí Security Approval Required\n\n`;
            message += `### Security Reviewers:\n\n`;
            
            // Add security reviewers from CODEOWNERS
            if (codeownerSecurityReviewers.size > 0) {
              message += `#### From CODEOWNERS:\n\n`;
              message += Array.from(codeownerSecurityReviewers).map(reviewer => `- ${reviewer}`).join('\n');
              message += '\n\n';
            }
            
            // Add additional security reviewers
            const additionalSecurityReviewers = securityReviewers.filter(reviewer => !codeownerSecurityReviewers.has(reviewer));
            if (additionalSecurityReviewers.length > 0) {
              message += `#### Additional Security Reviewers:\n\n`;
              message += additionalSecurityReviewers.map(reviewer => `- ${reviewer}`).join('\n');
              message += '\n\n';
            }
            
            message += `> ‚ö° Security review is required for this PR. Please ensure all security reviewers approve the changes.\n\n`;
          }
          
          if (customMessage) {
            message += `\n### ‚ÑπÔ∏è Info\n\n${customMessage}\n\n`;
          }
          
          message += `\n---\n`;
          message += `*This comment was automatically generated by the CODEOWNERS Reviewers action*`;
          
          // Add comment to PR
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: message
          });
          
          // Set output
          core.setOutput('reviewers', Array.from(reviewers).join(','));
