name: 'Get CODEOWNER reviewers'
description: 'Gets the CODEOWNER reviewers for changed files in a PR and posts them as a comment'
inputs:
  custom_message:
    description: 'Optional custom message to include in the comment'
    required: false
    default: ''
  codeowners_path:
    description: 'Path to the CODEOWNERS file'
    required: false
    default: '.github/CODEOWNERS'
  security_reviewers:
    description: 'Comma-separated list of security reviewers to include'
    required: false
    default: ''
outputs:
  reviewers:
    description: 'List of reviewers found for the changed files'
    value: ${{ steps.get-reviewers.outputs.reviewers }}

runs:
  using: "composite"
  steps:
    - name: Get CODEOWNERS reviewers
      id: get-reviewers
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          // Get changed files in the PR
          const { data: changedFiles } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          
          // Get CODEOWNERS file
          const codeownersPath = core.getInput('codeowners_path');
          let codeownersContent = '';
          
          try {
            console.log(`Attempting to retrieve CODEOWNERS file from path: ${codeownersPath}`);
            
            // First try to list files in the .github directory to see if CODEOWNERS exists
            try {
              const { data: dirContents } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.github'
              });
              console.log(`Contents of .github directory:`, dirContents.map(item => item.name));
            } catch (dirError) {
              console.log(`Could not list .github directory: ${dirError.message}`);
            }
            
            // Now try to get the actual CODEOWNERS file
            console.log(`Fetching CODEOWNERS file from: ${codeownersPath}`);
            
            if (!codeownersPath) {
              throw new Error('codeowners_path is empty or undefined');
            }
            
            let codeowners;
            try {
              const { data } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: codeownersPath
              });
              codeowners = data;
            } catch (error) {
              console.log(`Failed to retrieve CODEOWNERS from ${codeownersPath}, trying alternate paths...`);
              
              // Try alternate common locations
              const fallbackPaths = [
                'CODEOWNERS',
                '.github/CODEOWNERS',
                'docs/CODEOWNERS',
                '.gitlab/CODEOWNERS'
              ];
              
              let foundFile = false;
              for (const path of fallbackPaths) {
                if (path === codeownersPath) continue; // Skip the path we already tried
                
                try {
                  console.log(`Trying alternate path: ${path}`);
                  const { data } = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: path
                  });
                  codeowners = data;
                  console.log(`Found CODEOWNERS at alternate path: ${path}`);
                  foundFile = true;
                  break;
                } catch (fallbackError) {
                  console.log(`No CODEOWNERS at ${path}: ${fallbackError.message}`);
                }
              }
              
              if (!foundFile) {
                throw new Error(`CODEOWNERS file not found at ${codeownersPath} or any fallback locations`);
              }
            }
            
            // Add detailed logging of the API response
            console.log('Codeowners API response type:', typeof codeowners);
            console.log('Codeowners API response:', JSON.stringify(codeowners, null, 2));
            
            // Handle the case where the response is an array (directory listing)
            if (Array.isArray(codeowners)) {
              console.log('Received a directory listing instead of a file. Looking for CODEOWNERS file...');
              const codeownersFile = codeowners.find(file => file.name.toUpperCase() === 'CODEOWNERS');
              if (codeownersFile) {
                console.log('Found CODEOWNERS file in directory listing:', codeownersFile.path);
                // Fetch the actual file content
                const { data: actualFile } = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: codeownersFile.path
                });
                if (actualFile && actualFile.content) {
                  codeownersContent = Buffer.from(actualFile.content, 'base64').toString();
                } else {
                  throw new Error('CODEOWNERS file found in directory but content could not be retrieved');
                }
              } else {
                throw new Error(`CODEOWNERS file not found in directory listing for ${codeownersPath}`);
              }
            } else if (!codeowners) {
              throw new Error('GitHub API returned empty response for CODEOWNERS file');
            } else if (!codeowners.content) {
              throw new Error(`CODEOWNERS file found but has no content property. Response: ${JSON.stringify(codeowners)}`);
            } else {
              console.log(`Successfully retrieved CODEOWNERS file. Type: ${typeof codeowners.content}, Length: ${codeowners.content.length}`);
              codeownersContent = Buffer.from(codeowners.content, 'base64').toString();
              console.log(`CODEOWNERS content first 100 chars: ${codeownersContent.substring(0, 100)}`);
            }
          } catch (error) {
            console.log(`Error retrieving CODEOWNERS file: ${error.message}`);
            console.log(`Error details: ${JSON.stringify(error)}`);
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚ö†Ô∏è CODEOWNERS Error\n\nThere was an error processing the CODEOWNERS file at \`${codeownersPath}\`.\n\nError: \`${error.message}\`\n\nPlease check the GitHub Actions logs for more details.`
            });
            
            core.setFailed(`Failed to process CODEOWNERS file: ${error.message}`);
            core.setOutput('reviewers', '');
            return;
          }
          
          // Only proceed if we have content
          if (!codeownersContent || codeownersContent.trim() === '') {
            console.log('CODEOWNERS file is empty. Exiting.');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚ö†Ô∏è CODEOWNERS Warning\n\nThe CODEOWNERS file at \`${codeownersPath}\` exists but is empty.`
            });
            core.setOutput('reviewers', '');
            return;
          }
          
          const reviewers = new Set();
          
          // Parse CODEOWNERS file and create path patterns
          const codeownerRules = [];
          codeownersContent.split('\n').forEach(line => {
            if (line && !line.startsWith('#')) {
              const [pattern, ...owners] = line.trim().split(/\s+/);
              if (pattern && owners.length > 0) {
                codeownerRules.push({
                  pattern: pattern,
                  owners: owners.filter(owner => owner.startsWith('@'))
                });
              }
            }
          });
          
          // Sort rules by specificity (most specific first)
          codeownerRules.sort((a, b) => {
            const aDepth = a.pattern.split('/').length;
            const bDepth = b.pattern.split('/').length;
            return bDepth - aDepth;
          });
          
          // For each changed file, find matching CODEOWNERS rules
          changedFiles.forEach(file => {
            const filePath = file.filename;
            for (const rule of codeownerRules) {
              // Convert glob pattern to regex
              const pattern = rule.pattern
                .replace(/\*/g, '.*')
                // Convert single character wildcard ? to match any single character
                .replace(/\?/g, '.')
                // Preserve opening square bracket for character sets
                .replace(/\[/g, '[')
                // Preserve closing square bracket for character sets
                .replace(/\]/g, ']');
              const regex = new RegExp(`^${pattern}$`);
              
              if (regex.test(filePath)) {
                rule.owners.forEach(owner => reviewers.add(owner));
                break; // Stop at first match (most specific rule)
              }
            }
          });
          
          // Format the message
          const customMessage = core.getInput('custom_message');
          const securityReviewers = core.getInput('security_reviewers') ? core.getInput('security_reviewers').split(',').map(r => r.trim()) : [];
          
          // Separate regular reviewers from security reviewers
          const regularReviewers = new Set(Array.from(reviewers).filter(reviewer => !securityReviewers.includes(reviewer)));
          const codeownerSecurityReviewers = new Set(Array.from(reviewers).filter(reviewer => securityReviewers.includes(reviewer)));
          
          let message = `## üë• Required Reviewers\n\n`;
          
          if (regularReviewers.size > 0) {
            message += `### Reviewers for this PR:\n\n`;
            message += Array.from(regularReviewers).map(reviewer => `- ${reviewer}`).join('\n');
            message += '\n\n';
            message += `> üí° These reviewers were automatically assigned based on the files changed in this PR.\n`;
          } else if (codeownerSecurityReviewers.size === 0) {
            message += `> ‚ö†Ô∏è No CODEOWNERS found for the changed files in this PR.\n`;
            message += `> Please ensure you have a CODEOWNERS file set up in your repository.\n\n`;
          }
          
          if (codeownerSecurityReviewers.size > 0 || securityReviewers.length > 0) {
            message += `\n## üîí Security Approval Required\n\n`;
            message += `### Security Reviewers:\n\n`;
            
            // Add security reviewers from CODEOWNERS
            if (codeownerSecurityReviewers.size > 0) {
              message += `#### From CODEOWNERS:\n\n`;
              message += Array.from(codeownerSecurityReviewers).map(reviewer => `- ${reviewer}`).join('\n');
              message += '\n\n';
            }
            
            // Add additional security reviewers
            const additionalSecurityReviewers = securityReviewers.filter(reviewer => !codeownerSecurityReviewers.has(reviewer));
            if (additionalSecurityReviewers.length > 0) {
              message += `#### Additional Security Reviewers:\n\n`;
              message += additionalSecurityReviewers.map(reviewer => `- ${reviewer}`).join('\n');
              message += '\n\n';
            }
            
            message += `> ‚ö° Security review is required for this PR. Please ensure all security reviewers approve the changes.\n\n`;
          }
          
          if (customMessage) {
            message += `\n### ‚ÑπÔ∏è Info\n\n${customMessage}\n\n`;
          }
          
          message += `\n---\n`;
          message += `*This comment was automatically generated by the CODEOWNERS Reviewers action*`;
          
          // Add comment to PR
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: message
          });
          
          // Set output
          core.setOutput('reviewers', Array.from(reviewers).join(','));
